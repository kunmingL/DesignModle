package com.km.proxymodel;

/**
 * 代理模式
 * 解决问题：在方法的执行前后，做一些技术处理
 * 解决思路：创建动态代理类实现InvocationHandler接口
 * 在invoke方法中实现 增加方法的前后处理
 *
 * 代理模式和装饰模式是两种常见的设计模式，它们有一些相似之处，但也有一些明显的区别。
 *
 * 目的不同：
 *
 * 代理模式的主要目的是控制对对象的访问，可以在访问对象之前或之后添加一些额外的逻辑。代理模式通常用于实现对象的远程访问、延迟加载、权限控制等。
 * 装饰模式的主要目的是在不改变原始对象的结构的情况下，动态地给对象添加额外的功能。装饰模式通常用于在运行时动态地给对象添加新的行为或责任。
 * 关注点不同：
 *
 * 代理模式关注的是对对象的访问控制，代理对象通常会对真实对象进行一些额外的处理，例如记录日志、缓存数据等。
 * 装饰模式关注的是对对象的功能扩展，装饰对象会在不改变原始对象的情况下，动态地添加新的功能或行为。
 * 对象关系不同：
 *
 * 代理模式中，代理对象和真实对象通常具有相同的接口，客户端无法直接访问真实对象，而是通过代理对象来间接访问。
 * 装饰模式中，装饰对象和原始对象具有相同的接口，客户端可以直接访问装饰对象，装饰对象会在调用原始对象的方法之前或之后执行一些额外的操作。
 * 总的来说，代理模式主要用于控制对对象的访问，而装饰模式主要用于给对象动态地添加功能。代理模式更关注对对象的访问控制，而装饰模式更关注对对象的功能扩展。
 *
 */
public class ProxyModel {
}
